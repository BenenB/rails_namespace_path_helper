# frozen_string_literal: true
require_relative "rails_namespace_path_helper/version"
require_relative "rails_namespace_path_helper/railtie"

module RailsNamespacePathHelper

  # This helper dynamically creates aliases for helpers generated by rails
  # eg. in Admin:TasksController, tasks_url becomes an alias for admin_tasks_url

  # These helpers are declared locally on the controller to avoid conflicts 

  def has_namespaced_paths

    has_namespaced_path_singular
    has_namespaced_path_plural
  end

  def has_namespaced_path_singular
    # separate controller name from namespace
    model,namespaces = *parse_class_name

    ['url','path'].each do |tag|
      helper = "#{model.singularize}_#{tag}"

      # short circuit if conflict      
      next unless ensure_methods_available(namespaces, helper)

      # create aliases...
      define_namespace_helpers(namespaces,helper)
    end
  end

  def has_namespaced_path_plural
    # separate controller name from namespace
    model,namespaces = *parse_class_name

    ['url','path'].each do |tag|
      helper = "#{model.pluralize}_#{tag}"

      # short circuit if conflict
      next unless ensure_methods_available(namespaces, helper)

      # create aliases...
      define_namespace_helpers(namespaces,helper)
    end
  end

  private
  def parse_class_name
    model = self.name.split("::")[-1].gsub(/(.*)Controller$/,'\1').downcase
    namespaces = self.name.split("::")[0...-1].join("_").downcase
    return [model,namespaces]
  end

  def ensure_methods_available namespaces,helper
    # false if helper is not defined
    self.new.respond_to?("#{namespaces}_#{helper}".to_sym) &&  
    # false if alias is already defined AND can resolve properly
    !(self.new.respond_to?("#{helper}".to_sym) && (self.new.send(helper) rescue false))
  end

  def define_namespace_helpers namespaces,helper
      self.define_method(helper.to_sym) do 
        self.send("#{namespaces}_#{helper}".to_sym)
      end    
  end

end
